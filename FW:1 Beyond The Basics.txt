Adding Structure to ColdFusion Applications with FW/1: Beyond the Basics

---
240 seconds - 3 wps (18 minutes of talk!)

Good morning, my name's Marcin Szczepanski and today I'm going to be talking to you about adding some structure to Coldfusion applications, specifically using FW/1. I'll be covering some more of the "advanced" features in the framework, for want of a better word, but essentially just showing you some of the features available that you might not be aware of or have used.

First a bit about my background. I work for webqem, a digital agency based in Sydney, as a "developer" - essentially covering everything from backend to frontend. I've been developing with Coldfusion for almost 6 years, basically from around the CFMX/CF7 days, but have been involved with the web professionally since 1999.

I started using FW/1 about two years ago, as it seemed to be a nice change from some of the "heavier" CF frameworks out there like FuseBox, ColdBox, etc.

What attracted me to this framework was it's simplicity - it's a single CFC that you drop into your application, and have your App.cfc extend. It favours convention over configuration, so you need to do very little in order to get a simple app up and running using the framework.

The reason this presentation includes the phrase "adding structure to Coldfusion Applications" is because I believe that CF often gets a bad rap for the same sort of reasons PHP does - the mixing of code and presentation, and is seen as spaghetti code. However as with PHP there's no reason you can't write well organised CF applications, and I think FW/1 is a great way to add this structure without a huge amount of overhead.


So what I'm going to cover in today's presentation is:
* a quick background and refresher on FW/1 and the basics, but not in any huge detail
* we'll dive into how FW/1 works with dependency injection frameworks like Sean Corfield's own DI/1 or more commonly Coldspring
* We'll cover sub-systems and how you can use them to break up your application into re-useable logical units
* We'll talk about FW/1 routes and how they can be used to provide "pretty" URLs and REST style APIs
* And lastly we'll touch on some ideas for how you can test the various components of your FW/1 applications

So first a quick FW/1 refresher - we'll do a whirlwind tour of the major components of an FW/1 application, hopefully if you're new to FW/1 you'll still at least be able to get the general gist of how FW/1 applications are structured.

FW/1 comprises of a single CFC, called framework.cfc. To use the framework you have your application.cfc extend framework.cfc.  FW/1 is designed to provide convention over configuration, this means that there's nothing to setup in application.cfc unless you want to override the defaults.

The 3 parts of the Model-View-Controller pattern are implemented in a FW/1 application by services, controllers, views and layouts.
---
To access functions within an FW/1 application you use actions - an example of an action is "default.main" - it is comprised of a section and item name. This is actually FW/1's default action.

With FW/1s convention over configuration approach this means that the framework looks for a controller called default.cfc in the directory "controllers", it then calls a function in this controller called "main". Having a controller is optional, and if it does exist then the view still gets rendered.

So for the view part, each action has a corresponding view  - these are CFM pages named the same as the item, and they sit in a subdirectory with the name of the section, within the views directory.

A view is the only required part of a FW/1 application, without a view there's nothing to render so the framework throws an error.  With the default configuration a minimal FW/1 app requires a single view in views/default/main.cfm - even if the controller doesn't exist this view still gets rendered when the action is requested.

So letâ€™s have a look at the structure of a minimal FW/1 application...

[Show example]

So then going up another level a view can be rendered inside a layout - the default layout is in layouts/default.cfm - a layout needs output the contents of the "body" variable to include the output of views lower in the hierarchy.

Layouts can be nested, so FW/1 will first check for an item specific layout in "layouts/section/item.cfm"

Then a section layout in "layouts/section.cfm", and finally the default layout.

Each layout must cfoutput "body" to render the output from lower down the stack.  Nesting can be stopped by setting request.layout = false in the layout CFM file - this can even be used in a view to prevent the default layout from being used.


So back to the controller, assuming you actually want to do something more than rendeering static views, which you probably do, each function receives a "request context" structure in a variable called "rc". Your controller's job is to read any user supplied data out of rc, it is automatically populated with the content of any FORM and GET variables, and you set any new properties on rc that are then accessible by the view.
---

[Quick DEMO? - 1 min]

.. and in a nutshell that covers most of what FW/1 does at it's most basic level.

Services & Dependency Injection
-------------------------------

So first let's talk about services and dependency injection.  I didn't cover services in the basics above, but services are what your controllers call on in order to perform the business logic required for your application to function.

Prior to version 2 of FW/1 there were implicit service calls - this meant that for an action default.main the framework would look for a services/default.cfc - it would then call that CFCs "main" method, matching the names of any parameters to those found in the request context.

So for example if you had a login(username, password) method in your default service, and you POSTed to the default.login action with a username/password form variable then the framework would automatically call the service method with the right values passed in.

Now the tricky thing about this was that the implict service call would be _queued_ after your controller function finished. This meant that you didn't have access to the service results in your function, however there were some additional functions that FW/1 would call, if they existed, to make this easier to manage - namely beforeMethod and afterMethod - so for a request to default.main the main part of the call trace would look like this:

* beforeMain
* main
* [service called here]
* afterMain

Sean's thinking behind this functionality was that controller methods that just called a service and rendered a view could be eliminated - note that the service would still be called even if there was no default.cfc main function.

However this was a frequent source of confusion, and so starting with version 2 of the framework implicit service calls were disabled by default and it was recommended to access services via a bean factory / dependency injection framework explicitly from a controller method - sometimes too much convention can be detrimental!

So what's a DI framework do? At it's most basic level it separates dependencies between your compoennts from the components themselves - this means that say your controller requires a PersonService - rather than doing a "variables.personService = createObject("component", "model.service.person").init()" you just declare a "personService" property and have handling the setting of that property on your controller with an appropriate component be handled by your DI framework.

The advantages of this are many:
* you don't have to handle the lifetime of your services
* complex inter-dependencies between compoenents can be handled and resolved by the DI framework
* it makes it easy to swap out one component providing the same API for another

So how does FW/1 use a DI framework?

The core of any DI framework is called a Bean Factory - it provides objects in response to queries for a named object - so a call to beanFactory.getBean("personService") would return whatever component, or bean, had been defined as "personService" in the bean factory's configuration.

In FW/1, in your setupApplication() method, you give FW/1 access to a bean factory by calling setBeanFactory to your beanFactory of choice.  Essentially any component that responds to a "getBean" and "containsBean" method can be used as a Bean Factory.

Before I cover Coldspring, which is the de-facto and most well known Coldfusion DI framework I'll talk briefly about DI/1. DI/1 was created by Sean Corfield (creator of FW/1) and shares a lot of the same philosophies in terms of convention over configuration. In its default configuration it assumes everything in a directory called "model" is a bean, you can use sub-directories to help separate your beans.

So model/personService.cfc would be "personService" in the Bean Factory and model/dao/person.cfc would be "personDAO" to the Bean Factory.

DI/1 does what is called auto-wiring - this means that it will search for properties and constructor arguments on your beans that match the names of components known to the bean factory and will INJECT those beans.

So let's say I have an component called personService.cfc. This component relies on a component called personDAO.cfc to perform database access. Without a DI factory if we wanted to use personService we would need code like the following:

createObject("component", "model.service.person").init();

.. this assumes that personService had a constructor that did something like:
variables.personDAO = createObject("component", "model.dao.person").init();

If we wanted to pass in the DAO when creating the service we would need to do:

personDAO = createObject("component", "model.dao.person").init();
createObject("component", "model.service.person").init(personDAO);

.. with a constructor like:

... (required any personDAO) ...

With DI we can just do beanFactory.getBean("personService") which will:
- see that personService takes an instance personDAO as a constructor argument
- create a new instance of personDAO
- create a new instance of personService passing personDAO
- return personService

.. the other part of this is most of these kind of service beans are considered singletons - that means the bean factory will only ever instanciate one instance of each, so next time you ask the bean factory for personService you'll get back the previously created one, which saves some overhead.

So just to show a basic example of using a bean factory with FW/1:

[demo with a controller that has a personService property]

DI/1 is nice and simple, and will probably be more than enough for most of your cases, however the most well known DI framework for CF is Coldspring, now maintained by CFOANZs own Mark Mandel. The Coldspring API is based on the Spring framework from Java land. Coldspring is generally configured via an XML file, and instanciating a Coldspring bean factory looks something like this:

[ example ]

So using the "personService" example, at it's most basic in the coldspring.xml file we map the id "personService" to our personService component, we map "personDAO", and ensure we have default-autowire="byName".

This gives us equivalent functionality to what we did above with DI/1 with _no_ configration. However a common use case for DI is easily replacing the implementation of a component.  Let's say we have a personSQLDAO and a personStaticDAO - both with the same API.

In the coldspring.xml we define these beans, and then pass the one we want into LoginService when it's constructed.

We can actually do the same sort of thing with DI/1, but it requires a bit of configuration - we have to define an "alias" - so we alias personDAO to be the component that we want to use personSQLDAO or personStaticDAO. Still pretty simple.

You can also create aliases for static constants - for example you could do [TODO add constant "ftpServer" = "127.0.0.1" and pass into an remoteFileService which takes ctor arg]

Coldspring does a heck of a lot more than this - but that's beyond the scope of this talk. Check out the docs for the full set of features.

While FW/1 does autowiring into controllers of components from the bean factory you can also use the bean factory for getting the controllers themselves [TODO how does it do the search?]


Routes
------

The canonical URL format to access a FW/1 action is index.cfm?action=section.method, however FW/1 supports a number of ways to provide cleaner URLs, the first of these is the ability to take advantage of the PATH_INFO CGI variable to accept URLs like index.cfm/action/section. As a part of this you can actually also pass the parameters into the path rather than using the query string - eg. index.cfm/action/section/id/5 is equivalent to index.cfm/action/section?id=5

As long as you have setup the appropriate rewrite rules on your web server you can also eliminate the index.cfm part of the URL using the omitIndex (?) config option.

Last of all FW/1 provides support for mapping of arbitrary URL patterns to actions using routes - this functionality is also known as "friendly" or "SES" URLs.

Routes are purely a visual thing, they don't offer any additional functionality you don't already get through a standard "action" URL. Generally they're used for SEO, providing easily memoriseable URLs or providing a consistent API.

Routes are defined in the FW/1 config file, and a simple route definition looks like this:

/home => /main/default

which means you can now go to index.cfm/home

or you can use parameters such as:

/person/:id => people.person/id/:id

which means you can go to an URL like /index.cfm/person/1 (note that with route mappings you can't output a query string)

Routes are processed in order from the start to the end of the route array, and processing is stopped on the first match.

You can further limit the scope of a route match by providing a method that this route applies to - for example $GET/person/:id will only match for a GET request but not a POST.

What this means is with the right set of routes you can actually create a REST based API:

[example of REST routes]

There's a few routes required to provide the full set of capabilities for an object, but it's not too onerous. I'm actually planning to submit a patch for FW/1 that will let you simplify all that with:

$RESOURCE/person

However I haven't yet got around to writing that one, so you'll have to do it the long way for now!

The other caveat with those routes is they require a patch that's not in the current "stable" release of FW/1, this patch adds support for doing your own custom regex matching in a route, rather than just simple placeholder matching.

[Demo? Backbone app talking to FW/1 REST controller]

Just a quick caveat with routes - in the current release version of FW/1 the routes are only simple matches, so /person/:id will match /person/1 and also /person/1/contacts - you can't get around this by doing /person/:id/contacts and /person/:id second - however in the latest HEAD version on Github there's some basic support for some additional regex support in routes like /person/:id$

So now we've talked about how you can provide model service to your application, and how you can use friendly URLs and also create "RESTful" service with FW/1 routes let's talk about 
breaking applications into re-useable components.

Recently I saw Ray Camden show how easy it is with CF10 REST services to return different representations depending on what was asked for. You can also do this quite easily with FW/1 routes:

[show demo with returning different data types]

.. now in this example I've based what gets returned on the extension requested, however you could just as easily use the "Accepts" header.

[demo of accepts?]

You might want to break up your application either because you want to more easily re-use parts in other applications or just that they're logically different parts of a whole - like say an admin system vs a public site. FW/1 allows you to do this with support for something called sub-systems.

To turn on sub-systems in your application you need to add a config option variables.framework.usingSubsystems = true

By turning sub-systems on it means that the way an action looks is slightly different. The default action is now

default:default.main

the first part is the name of the sub-system that handles that action.  As with everything else this is by convention, and the default sub-system is called default.

So at the basic level, if you wanted to use sub-systems to split up your site into an "admin" and "public" sub-system you would end up with a folder structure like this:

..

As you can see each sub-system has it's own self-contained set of controllers and views - this means you could easily take this whole sub-system and drop it into another FW/1 application. Apart from the sub-system specific stuff there is a common layout folder.  This means the bubbling for layouts now becomes:

subsystem/layouts/section/method
subsystem/layouts/section
subsystem/layouts/default.cfm
common/layouts/default.cfm

[Demo of basic Public / Admin system]

In addition, if you are using Dependency Injection you can provide separate bean factories per sub-system, or just keep using a single bean factory. This means you can even separate your service components where they aren't common.

[Demo of above with auth services moved to admin sub-system and new bean factory]

So that's our tour of some of the more advanced features of FW/1 - by using all these features you can provide a cleaner structure to your CF applications, it becomes much easier to re-use code between your applications, and it keeps the different parts of the application logically separated.

One last thing I'd like to discuss is testing of FW/1 applications.

If you've done everything mostly right in terms of structuring your application to keep it loosely coupled then it will better lend itself to testing. You can tests your services in isolation, your controllers in isolation, and your views in isolation. Writing tests early is a good way to weed out these so called tight coupling - if you find something is hard to test because it has some external dependencies then it's probably a good candidate for further splitting up.

The "standard" testing framework in the Coldfusion world is mxunit, so that's what I'll be using today.

Staring with the controller - it's important to remember when testing your controllers that you're not testing the framework, so you should be able to just use your standalone controller component to test. You setup the request context with the required variables, call your controller function, and then inspect rc to assert that the values in rc are now what you expect them to be.

However if your controller calls a service to get data, then these service calls should be mocked and the mock service injected into your controller.

[Example]

So what about testing your templates? This can be done with a similar approach - you setup a request context structure with the variables you'd expect to be in there and then include the template, saving the output.  This is functionally similar to what FW/1 does under the hood to render the output.

[Example]

You can then either do simple string matching to ensure that the data you expect is in the output, or you can use a library like JSoup to do more advanced matching. JSoup is a port of a python HTML parsing library called BeautifulSoup - after parsing the content it gives you a nice object you can do all sorts of queries on to get data out.

[Example]

OK, so after that whirlwind tour where are we at? We've shown how FW/1 can be used to add structure and separation to your application with it's implementation of the Model-View-Controller pattern. We've shown how you can use dependency injection to reduce coupling between components. We've covered routes which allow you to make "friendly" URLs and provide consistent APIs. We've talked about sub-systems and how they can be used to break an application into re-useable modules. And last but not least we've covered a little on testing FW/1 applications.


Resources
* Github
* Mailing list
* Contribute!